# КВ_4 Сигналы и обработчики
Одним из способов организации взаимодействия объектов вне схемы взаимосвязи является механизм сигналов и обработчиков. Вместе с передачей сигнала еще передаются определенное множество данных. Механизм сигналов и обработчиков реализует схему взаимодействия объектов один ко многим.

Для организации взаимосвязи по механизму сигналов и обработчиков в базовый класс необходимо добавить три метода:

1. Установления связи между сигналом текущего объекта и обработчиком целевого объекта.
2. Удаления (разрыва) связи между сигналом текущего объекта и обработчиком целевого объекта.
3. Выдачи сигнала от текущего объекта с передачей строковой переменной.

Методу установки связи необходимо передать указатель на метод сигнала текущего объекта, указатель на целевой объект и указатель на метод обработчика целевого объекта.

Методу удаления (разрыва) связи необходимо передать указатель на метод сигнала текущего объекта, указатель на целевой объект и указатель на метод обработчика целевого объекта.

Методу выдачи сигнала необходимо передать указатель на метод сигнала текущего объекта и строковую переменную. В данном методе надо реализовать алгоритм:
1. Вызов метода сигнала с передачей строковой переменной по ссылке.
2. Цикл по всем связям сигнал-обработчик текущего объекта:
   +  2.1. Если в очередной связи сигнал-обработчик участвует метод сигнала, переданный по параметру, то вызвать метод обработчика очередного целевого объекта и передать в качестве аргумента строковую переменную по значению.
3. Конец цикла.
Для приведения указателя на метод сигнала и на метод обработчика можно использовать параметризированное макроопределение препроцессора.

Например:

Для получения указателя на метод сигнала объекта:
```cpp
#define SIGNAL_D(signal_f) (TYPE_SIGNAL) (&signal_f)
```
Для получения указателя на метод обработчика объекта:
```cpp
#define HANDLER_D(handler_f) (TYPE_HANDLER)(&hendler_f)
```
Для определения указателей на метод сигнала и метод обработчика, можно воспользоваться определением новых типов данных:

Указатель на метод сигнала объекта:
```cpp
typedef void(cl_base::*TYPE_SIGNAL) (string&);
```

Указатель на метод обработчика объекта:
```cpp
typedef void(cl_base::*TYPE_HANDLER) (string);
```

Необходимо задать пространство имен базового класса cl_base ::  - это определяет, что указатель относится к методу базового класса.

Исходя из требования, что, надо реализовать связь сигнала ко многим обработчикам, и возможности определить для объекта произвольное количество сигналов и обработчиков, встает задача хранения этой информация в составе текущего объекта. Тогда в заголовочной части базового класса можно определить структуру:
```cpp
struct o_sh                 // Структура задания одной связи
{
  TYPE_SIGNAL p_signal;     // Указатель на метод сигнала
  cl_base* p_cl_base;       // Указатель на целевой объект
  TYPE_HANDLER p_handler;   // Указатель на метод обработчика
}
```

А для хранения установленных связей можно объявить вектор:
```cpp
vector<o_sh*> connects;
```

Например, реализация метода установки связи может иметь вид:
```cpp
void cl_base::set_connect(TYPE_SIGNAL p_signal, cl_base* p_object, TYPE_HANDLER p_ob_handler)
{
    o_sh* p_value;                                     
    //--------------------------------------------------------
    // Цикл для исключения повторного установления связи
    for (unsigned int i = 0; i < connects.size(); i++)   
    {                                                        
        if (connects[i]->p_signal == p_signal && connects[i]->p_cl_base == p_object && connects[i]->p_handler == p_ob_handler)
        {                                                    
            return;                                          
        }                                                    
    }                                                        
                                                               
    p_value = new o_sh();                    // создание объекта структуры для
                                             // хранения информации о новой связи
    p_value->p_signal = p_signal;                          
    p_value->p_cl_base = p_object;                          
    p_value->p_handler = p_ob_handler;                      
                                                               
    connects.push_back(p_value);            // добавление новой связи                 
}
```

Например, реализация метода выдачи сигнала и отработки соответствующих обработчиков может содержать следующие фрагменты кода:
```cpp
void cl_base::emit_signal(TYPE_SIGNAL p_signal, string& s_command)
{
    TYPE_HANDLER p_handler;
    cl_base* p_object;
    //-------------------------------------------------------------------------
   (this->*p_signal)(s_command);                         // вызов метода сигнала
   for (unsigned int i = 0; i < connects.size(); i++)    // цикл по всем обработчикам
   {
        if (connects[i]->p_signal == p_signal)           // определение допустимого обработчика
        {                               
            p_handler = connects[i]->p_handler;
            p_object = connects[i]->p_cl_base;
 
            (p_object->*p_handler)(s_command);           // вызов метода обработчика
        }
    }
}
```

## Постановка задачи
Реализовать механизм взаимодействия объектов с использованием сигналов и обработчиков, с передачей вместе сигналом текстового сообщения (строковой переменной).

Для организации взаимосвязи по механизму сигналов и обработчиков в базовый класс добавить три метода:
+ установления связи между сигналом текущего объекта и обработчиком целевого объекта;
+ удаления (разрыва) связи между сигналом текущего объекта и обработчиком целевого объекта;
+ выдачи сигнала от текущего объекта с передачей строковой переменной. Включенный объект может выдать или обработать сигнал.

Методу установки связи передать указатель на метод сигнала текущего объекта, указатель на целевой объект и указатель на метод обработчика целевого объекта.

Методу удаления (разрыва) связи передать указатель на метод сигнала текущего объекта, указатель на целевой объект и указатель на метод обработчика целевого объекта.

Методу выдачи сигнала передать указатель на метод сигнала и строковую переменную. В данном методе реализовать алгоритм:

1. Если текущий объект отключен, то выход, иначе к пункту 2.
2. Вызов метода сигнала с передачей строковой переменной по ссылке.
3. Цикл по всем связям сигнал-обработчик текущего объекта:
    + 3.1. Если в очередной связи сигнал-обработчик участвует метод сигнала, переданный по параметру, то проверить готовность целевого объекта. Если целевой объект готов, то вызвать метод обработчика целевого объекта указанной в связи и передать в качестве аргумента строковую переменную по значению.
4. Конец цикла.

Для приведения указателя на метод сигнала и на метод обработчика использовать параметризированное макроопределение препроцессора.

В базовый класс добавить метод определения абсолютной пути до текущего объекта. Этот метод возвращает абсолютный путь текущего объекта.

Состав и иерархия объектов строится посредством ввода исходных данных. Ввод организован как в версии № 3 курсовой работы. Если при построении дерева иерархии возникает ситуация дубляжа имен среди починенных у текущего головного объекта, то новый объект не создается.

Система содержит объекты шести классов с номерами: 1, 2, 3, 4, 5, 6. Классу корневого объекта соответствует номер 1. В каждом производном классе реализовать один метод сигнала и один метод обработчика.

Каждый метод сигнала с новой строки выводит:
> Signal from «абсолютная координата объекта»

Каждый метод сигнала добавляет переданной по параметру строке текста номер класса принадлежности текущего объекта по форме:
> «пробел»(class: «номер класса»)

Каждый метод обработчика с новой строки выводит:
> Signal to «абсолютная координата объекта»   Text: «переданная строка»

Моделировать работу системы, которая выполняет следующие команды с параметрами:
+ EMIT «координата объекта» «текст» – выдает сигнал от заданного по координате объекта;
+ SET_CONNECT «координата объекта выдающего сигнал» «координата целевого объекта» – устанавливает связь;
+ DELETE_CONNECT «координата объекта выдающего сигнал» «координата целевого объекта» – удаляет связь;
+ SET_CONDITION «координата объекта» «значение состояния» – устанавливает состояние объекта.
+ END – завершает функционирование системы (выполнение программы).

Реализовать алгоритм работы системы:
+ в методе построения системы:
    + построение дерева иерархии объектов согласно вводу;
    + ввод и построение множества связей сигнал-обработчик для заданных пар объектов.
+ в методе отработки системы:
    + привести все объекты в состоянии готовности;
    + цикл до признака завершения ввода:
        + ввод наименования объекта и текста сообщения;
        + вызов сигнала заданного объекта и передача в качестве аргумента строковой переменной, содержащей текст сообщения.
    + конец цикла.

Допускаем, что все входные данные вводятся синтаксически корректно. Контроль корректности входных данных можно реализовать для самоконтроля работы программы. Не оговоренные, но необходимые функции и элементы классов добавляются разработчиком.

_При решении задачи необходимо руководствоваться методическим пособием и приложением к методическому пособию_

## Входные данные
В методе построения системы.

Множество объектов, их характеристики и расположение на дереве иерархии. Структура данных для ввода согласно изложенному в версии № 3 курсовой работы.

После ввода состава дерева иерархии построчно вводится:
> «координата объекта выдающего сигнал» «координата целевого объекта»

Ввод информации для построения связей завершается строкой, которая содержит:
> «end_of_connections»

В методе запуска (отработки) системы построчно вводятся множество команд в производном порядке:
+ EMIT `координата объекта` `текст` – выдать сигнал от заданного по координате объекта;
+ SET_CONNECT `координата объекта выдающего сигнал` `координата целевого объекта` – установка связи;
+ DELETE_CONNECT `координата объекта выдающего сигнал` `координата целевого объекта` – удаление связи;
+ SET_CONDITION `координата объекта` `значение состояния` – установка состояния объекта.
+ END – завершить функционирование системы (выполнение программы).

Команда END присутствует обязательно.

Если координата объекта задана некорректно, то соответствующая операция не выполняется и с новой строки выдается сообщение об ошибке.

Если не найден объект по координате:
> Object «координата объекта» not found

Если не найден целевой объект по координате:
> Handler object «координата целевого объекта» not found
 
Пример ввода:
```
appls_root
/ object_s1 3
/ object_s2 2
/object_s2 object_s4 4
/ object_s13 5
/object_s2 object_s6 6
/object_s1 object_s7 2
endtree
/object_s2/object_s4 /object_s2/object_s6
/object_s2 /object_s1/object_s7
/ /object_s2/object_s4
/object_s2/object_s4 /
end_of_connections
EMIT /object_s2/object_s4 Send message 1
EMIT /object_s2/object_s4 Send message 2
EMIT /object_s2/object_s4 Send message 3
EMIT /object_s1 Send message 4
END
```
## Выходные данные
Первая строка:
> Object tree

Со второй строки вывести иерархию построенного дерева.

Далее, построчно, если отработал метод сигнала:
> Signal from «абсолютная координата объекта»

Если отработал метод обработчика:
> Signal to «абсолютная координата объекта»   Text: «переданная строка»

Пример вывода:
```
Object tree
appls_root
    object_s1
        object_s7
    object_s2
        object_s4
        object_s6
    object_s13
Signal from /object_s2/object_s4
Signal to /object_s2/object_s6 Text:  Send message 1 (class: 4)
Signal to / Text:  Send message 1 (class: 4)
Signal from /object_s2/object_s4
Signal to /object_s2/object_s6 Text:  Send message 2 (class: 4)
Signal to / Text:  Send message 2 (class: 4)
Signal from /object_s2/object_s4
Signal to /object_s2/object_s6 Text:  Send message 3 (class: 4)
Signal to / Text:  Send message 3 (class: 4)
Signal from /object_s1
```
---
### Автор - https://vk.com/aptekkkar
